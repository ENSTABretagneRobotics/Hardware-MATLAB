function [methodinfo,structs,enuminfo,ThunkLibName]=hardwarex_proto
%HARDWAREX_PROTO Create structures to define interfaces found in 'hardwarex'.

%This function was generated by loadlibrary.m parser version  on Sat Jun 27 16:48:51 2015
%perl options:'hardwarex.i -outfile=hardwarex_proto.m -thunkfile=hardwarex_thunk_pcwin64.c -header=hardwarex.h'
ival={cell(1,0)}; % change 0 to the actual number of functions to preallocate the data.
structs=[];enuminfo=[];fcnNum=1;
fcns=struct('name',ival,'calltype',ival,'LHS',ival,'RHS',ival,'alias',ival,'thunkname', ival);
MfilePath=fileparts(mfilename('fullpath'));
ThunkLibName=fullfile(MfilePath,'hardwarex_thunk_pcwin64');
%  HOKUYO * CreateHokuyox ( void ); 
fcns.thunkname{fcnNum}='voidPtrvoidThunk';fcns.name{fcnNum}='CreateHokuyox'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='HOKUYOPtr'; fcns.RHS{fcnNum}=[];fcnNum=fcnNum+1;
%  void DestroyHokuyox ( HOKUYO * pHokuyo ); 
fcns.thunkname{fcnNum}='voidvoidPtrThunk';fcns.name{fcnNum}='DestroyHokuyox'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}={'HOKUYOPtr'};fcnNum=fcnNum+1;
%  double k2angleHokuyox ( HOKUYO * pHokuyo , int k ); 
fcns.thunkname{fcnNum}='doublevoidPtrint32Thunk';fcns.name{fcnNum}='k2angleHokuyox'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='double'; fcns.RHS{fcnNum}={'HOKUYOPtr', 'int32'};fcnNum=fcnNum+1;
%  int angle2kHokuyox ( HOKUYO * pHokuyo , double angle ); 
fcns.thunkname{fcnNum}='int32voidPtrdoubleThunk';fcns.name{fcnNum}='angle2kHokuyox'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'HOKUYOPtr', 'double'};fcnNum=fcnNum+1;
%  int GetLatestDataHokuyox ( HOKUYO * pHokuyo , double * pDistances , double * pAngles ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrvoidPtrThunk';fcns.name{fcnNum}='GetLatestDataHokuyox'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'HOKUYOPtr', 'doublePtr', 'doublePtr'};fcnNum=fcnNum+1;
%  int ConnectHokuyox ( HOKUYO * pHokuyo , char * szCfgFilePath ); 
fcns.thunkname{fcnNum}='int32voidPtrcstringThunk';fcns.name{fcnNum}='ConnectHokuyox'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'HOKUYOPtr', 'cstring'};fcnNum=fcnNum+1;
%  int DisconnectHokuyox ( HOKUYO * pHokuyo ); 
fcns.thunkname{fcnNum}='int32voidPtrThunk';fcns.name{fcnNum}='DisconnectHokuyox'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'HOKUYOPtr'};fcnNum=fcnNum+1;
structs.s_iobuf.packing=8;
structs.s_iobuf.members=struct('m_ptr', 'cstring', 'm_cnt', 'int32', 'm_base', 'cstring', 'm_flag', 'int32', 'm_file', 'int32', 'm_charbuf', 'int32', 'm_bufsiz', 'int32', 'm_tmpfname', 'cstring');
structs.RS232PORT.members=struct('hDev', 'voidPtr', 's', 'uint64', 'szDevPath', 'int8#256', 'address', 'int8#256', 'port', 'int8#256', 'DevType', 'int32');
structs.HOKUYO.members=struct('RS232Port', 'RS232PORT', 'StepAngleSize', 'double', 'StepCount', 'int32', 'pfSaveFile', 's_iobufPtr', 'szCfgFilePath', 'int8#256', 'szDevPath', 'int8#256', 'BaudRate', 'int32', 'timeout', 'int32', 'bSaveRawData', 'int32', 'bForceSCIP20', 'int32', 'bHS', 'int32', 'SlitDivision', 'int32', 'StartingStep', 'int32', 'FrontStep', 'int32', 'EndStep', 'int32', 'ClusterCount', 'int32', 'ScanInterval', 'int32', 'bContinuousNumberOfScans', 'int32', 'alpha_max_err', 'double', 'd_max_err', 'double');
methodinfo=fcns;